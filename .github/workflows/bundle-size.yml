name: Bundle Size

on:
  pull_request:
    branches:
      - main

permissions:
  pull-requests: write

jobs:
  size:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR
        uses: actions/checkout@v5

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: 22
          cache: pnpm

      - name: Install and build PR
        run: pnpm install && pnpm build:packages

      - name: Measure PR bundle size
        run: pnpm -w exec size-limit --json > /tmp/pr-size.json

      - name: Measure base bundle size
        run: |
          git fetch origin ${{ github.base_ref }} --depth=1
          git checkout -f FETCH_HEAD

          pnpm install

          if [ -f .size-limit.json ]; then
            pnpm build:packages
            pnpm -w exec size-limit --json > /tmp/base-size.json
          else
            echo '[]' > /tmp/base-size.json
          fi

      - name: Report
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const pr = JSON.parse(fs.readFileSync('/tmp/pr-size.json', 'utf8'));
            const base = JSON.parse(fs.readFileSync('/tmp/base-size.json', 'utf8'));

            const baseMap = Object.fromEntries(base.map(e => [e.name, e.size]));

            function formatBytes(bytes) {
              if (bytes < 1024) return `${bytes} B`;
              return `${(bytes / 1024).toFixed(2)} kB`;
            }

            function formatDelta(current, previous) {
              if (previous === undefined) return { bytes: '‚Äî', pct: '' };
              const diff = current - previous;
              if (diff === 0) return { bytes: '0 B', pct: '0%' };
              const sign = diff > 0 ? '+' : '-';
              const pct = Math.abs((diff / previous) * 100).toFixed(1);
              return { bytes: `${sign}${formatBytes(Math.abs(diff))}`, pct: `${sign}${pct}%` };
            }

            function statusIcon(current, previous) {
              if (previous === undefined) return 'üÜï';
              const diff = current - previous;
              if (diff === 0) return '‚úÖ';
              if (diff < 0) return 'üîΩ';
              const pct = (diff / previous) * 100;
              return pct > 10 ? 'üî¥' : 'üî∫';
            }

            // Group entries by package: @videojs/utils/* -> utils, @videojs/store/* -> store, etc.
            const groups = new Map();
            for (const entry of pr) {
              const match = entry.name.match(/^@videojs\/([^/]+)/);
              const pkg = match ? match[1] : 'other';
              if (!groups.has(pkg)) groups.set(pkg, []);
              groups.get(pkg).push(entry);
            }

            const lines = [];
            let grandTotalPr = 0;
            let grandTotalBase = 0;

            for (const [pkg, entries] of groups) {
              const pkgTotalPr = entries.reduce((s, e) => s + e.size, 0);
              const pkgTotalBase = entries.reduce((s, e) => s + (baseMap[e.name] ?? 0), 0);
              const hasBase = entries.some(e => baseMap[e.name] !== undefined);
              grandTotalPr += pkgTotalPr;
              grandTotalBase += pkgTotalBase;

              // Subpath display: @videojs/utils/dom -> ./dom, @videojs/store -> .
              const displayName = (name) => {
                const sub = name.replace(`@videojs/${pkg}`, '');
                return sub ? `.${sub}` : '.';
              };

              const pkgPrev = entries.length > 1 ? pkgTotalBase : baseMap[entries[0].name];
              const pkgCur = entries.length > 1 ? pkgTotalPr : entries[0].size;
              const pkgDelta = formatDelta(pkgCur, pkgPrev);
              const hasDelta = entries.length > 1 ? hasBase : pkgPrev !== undefined;
              const pkgIcon = hasDelta ? ` ${statusIcon(pkgCur, pkgPrev)}` : '';
              const pkgSummary = `${formatBytes(pkgCur)}${hasDelta && pkgDelta.bytes !== '‚Äî' ? ` (${pkgDelta.bytes}) (${pkgDelta.pct})` : ''}`;

              lines.push(`<details>`);
              lines.push(`<summary><strong>@videojs/${pkg}</strong> ‚Äî ${pkgSummary}${pkgIcon}</summary>`);
              lines.push('');
              lines.push('| Subpath | Base | PR | Diff | % | |');
              lines.push('|---|--:|--:|--:|--:|:-:|');

              for (const entry of entries) {
                const prev = baseMap[entry.name];
                const d = formatDelta(entry.size, prev);
                lines.push(
                  `| \`${displayName(entry.name)}\` | ${prev !== undefined ? formatBytes(prev) : '‚Äî'} | **${formatBytes(entry.size)}** | ${d.bytes} | ${d.pct} | ${statusIcon(entry.size, prev)} |`
                );
              }

              if (entries.length > 1) {
                const d = formatDelta(pkgTotalPr, pkgTotalBase);
                lines.push(
                  `| **total** | **${hasBase ? formatBytes(pkgTotalBase) : '‚Äî'}** | **${formatBytes(pkgTotalPr)}** | **${hasBase ? d.bytes : '‚Äî'}** | **${hasBase ? d.pct : ''}** | |`
                );
              }

              lines.push('');
              lines.push('</details>');
              lines.push('');
            }

            const marker = '<!-- bundle-size-report -->';
            const body = [
              marker,
              '### üì¶ Bundle Size Report',
              '',
              ...lines,
              '---',
              '',
              (() => {
                const d = formatDelta(grandTotalPr, grandTotalBase);
                return `**Total: ${formatBytes(grandTotalPr)}**${grandTotalBase ? ` (${d.bytes}) (${d.pct})` : ''}`;
              })(),
              '',
              '<details>',
              '<summary>‚ÑπÔ∏è How to interpret</summary>',
              '',
              'Each package section shows its own code size with dependencies externalized.',
              'Sizes are minified + brotli compressed, measured via [size-limit](https://github.com/ai/size-limit) with esbuild.',
              '',
              '| Icon | Meaning |',
              '|---|---|',
              '| ‚úÖ | No change |',
              '| üî∫ | Size increased ‚â§ 10% |',
              '| üî¥ | Size increased > 10% |',
              '| üîΩ | Size decreased |',
              '| üÜï | New entry (no baseline) |',
              '',
              'Run `pnpm size` locally to check current sizes.',
              '</details>',
            ].join('\n');

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.find(c => c.body?.startsWith(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }
