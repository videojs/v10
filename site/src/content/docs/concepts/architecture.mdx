---
title: Architecture
description: Understanding the three-pillar architecture of Video.js v10+ - Player, Media, and UI
---

import FrameworkCase from '@/components/docs/FrameworkCase.astro';
import { TabsRoot, TabsList, TabsPanel, Tab } from '@/components/Tabs';
import DocsLink from '@/components/docs/DocsLink.astro';

Video.js v10+ is built around three independent pillars—**Player**, **Media**, and **UI/Skins**.

## The Three Pillars

### Player

The **Player** is the state and coordination root—think of it like an HTML `<form>` element. It doesn't render UI or play media directly. Instead, it provides shared state and coordinates between Media and UI components inside it.

<FrameworkCase frameworks={["react"]}>
```tsx
import { createPlayer, features } from '@videojs/react';

const { Provider, usePlayer } = createPlayer({
  features: features.video(),
});

<Provider>
  {/* All components inside can access player state */}
</Provider>
```
</FrameworkCase>
<FrameworkCase frameworks={["html"]}>
```html
<video-player>
  <!-- All components inside can access player state -->
</video-player>
```
</FrameworkCase>

<FrameworkCase frameworks={["html"]}>
For custom configurations, use `createPlayer()`:

```ts
import { createPlayer, features } from '@videojs/html';

const { Player } = createPlayer({
  features: features.video(),
});

Player.define('my-video-player');
```
</FrameworkCase>

**Features** bundle related state and requests (like Redux slices). Feature bundles range from specific capabilities to complete use-case configurations:

- `features.video()` — the default for `<video>`: playback, volume, time, fullscreen, keyboard, idle
- `features.audio()` — the default for `<audio>`: playback, volume, time, keyboard
- `features.backgroundVideo()` — minimal: playback only (autoplay, loop)
- `features.adaptive()` — add-on: quality selection for HLS/DASH streams
- `features.creator()` — use-case: video + quality selection, chapters

<DocsLink slug="concepts/features">Learn more about features →</DocsLink>

### Media

Media elements **display and process your video or audio**. They're enhanced versions of the native `<video>` and `<audio>` elements, named by their implementation and media type.

<FrameworkCase frameworks={["react"]}>
```tsx
// Native video
<Video src="video.mp4" />

// HLS streaming
<HlsVideo src="stream.m3u8" />

// DASH streaming
<DashVideo src="stream.mpd" />

// Service embeds
<YouTubeVideo videoId="dQw4w9WgXcQ" />
<VimeoVideo videoId="123456789" />
```
</FrameworkCase>
<FrameworkCase frameworks={["html"]}>
```html
<!-- Native video -->
<video src="video.mp4"></video>

<!-- HLS streaming -->
<hls-video src="stream.m3u8"></hls-video>

<!-- DASH streaming -->
<dash-video src="stream.mpd"></dash-video>

<!-- Service embeds -->
<youtube-video video-id="dQw4w9WgXcQ"></youtube-video>
<vimeo-video video-id="123456789"></vimeo-video>
```
</FrameworkCase>

Media is independent of the Player and UI—you can use any media type with any player configuration. Media exposes the same API as the native video element, so UI components work regardless of what's playing underneath.

<DocsLink slug="concepts/media">Learn more about media →</DocsLink>

### UI/Skins

The UI pillar has two layers:

**Skins** — Complete, pre-designed player UIs that package components and styles together:

<FrameworkCase frameworks={["html"]}>
- `<frosted-video-skin>` — Glassy, modern design
- `<minimal-video-skin>` — Clean, simple design
</FrameworkCase>
<FrameworkCase frameworks={["react"]}>
- `<FrostedSkin>` — Glassy, modern design
- `<MinimalSkin>` — Clean, simple design
</FrameworkCase>

<DocsLink slug="concepts/skins">Learn more about skins →</DocsLink>

**Components** — Unstyled UI primitives in the `media-*` namespace. These bind via context to the nearest player/media:
- Buttons (`media-play-button`, `media-mute-button`, `media-fullscreen-button`)
- Sliders (`media-time-slider`, `media-volume-slider`)
- Displays (`media-current-time`, `media-duration`)
- Compound components (Tooltip, Popover)

Most people start with a skin and eject it for customization. <DocsLink slug="how-to/customize-skins">Learn how to customize a skin →</DocsLink>

<DocsLink slug="concepts/ui-components">Explore UI components →</DocsLink>

#### Media and Feature Support

Not every media type supports every feature. For example, a native `<video>` playing an MP4 can't support a quality selector—there's only one quality. An HLS stream with multiple renditions can.

UI components can detect unsupported features and adapt (hiding the quality button when there's nothing to select). But if you're expecting a specific feature, make sure your media choice supports it:

| Feature | Native Video | HLS | DASH | YouTube |
|---------|--------------|-----|------|---------|
| Playback | ✓ | ✓ | ✓ | ✓ |
| Quality selection | — | ✓ | ✓ | ✓ |
| Chapters | ✓ | ✓ | ✓ | ✓ |
| Live | — | ✓ | ✓ | ✓ |

## How It All Works Together

<FrameworkCase frameworks={["react"]}>
```tsx
import { createPlayer, features } from '@videojs/react';
import { FrostedSkin } from '@videojs/react/skin/frosted';
import '@videojs/react/skin/frosted.css';

const { Provider } = createPlayer({
  features: features.video(),
});

function Player() {
  return (
    // Player: State coordination root
    <Provider>
      {/* UI: Skin */}
      <FrostedSkin>
        {/* Media: Independent choice */}
        <video src="video.mp4" />
      </FrostedSkin>
    </Provider>
  );
}
```
</FrameworkCase>

<FrameworkCase frameworks={["html"]}>
<TabsRoot client:visible>
  <TabsList client:visible label="HTML implementation">
    <Tab client:visible value="html" initial>HTML</Tab>
    <Tab client:visible value="javascript">JavaScript</Tab>
  </TabsList>
  <TabsPanel client:visible value="html" initial>

```html
<!-- Player: State coordination root -->
<video-player>
  <!-- UI: Skin -->
  <frosted-video-skin>
    <!-- Media: Independent choice -->
    <video src="video.mp4"></video>
  </frosted-video-skin>
</video-player>
```

  </TabsPanel>
  <TabsPanel client:visible value="javascript">

```ts
import '@videojs/html/player/video';
import '@videojs/html/skin/frosted';
import '@videojs/html/skin/frosted.css';
```

  </TabsPanel>
</TabsRoot>
</FrameworkCase>

## Mix and Match

The three-pillar architecture gives you flexibility:

- **Use everything** — Pick a use case, get a player + skin + media that work together
- **Swap the skin** — Use a different skin with the same player
- **Swap the media** — Use HLS instead of native video, same UI
- **Custom UI** — Use the player for state, build your own UI with primitives
- **Headless** — Use just the player layer for programmatic control, no UI

## Design Notes

This section covers the reasoning behind architectural decisions. Skip this if you're just getting started.

### Why "Player" Instead of "Provider"?

The Player element is modeled after HTML's `<form>`—a container that doesn't render visible UI itself but provides shared state and coordination for everything inside it. Just as a form collects inputs and handles submission, a player collects media state and coordinates playback.

We chose "Player" over "Provider" because:
- It matches what users expect ("I want a video player")
- It's concrete rather than abstract
- It parallels the `<form>` mental model

### Why This Naming Structure?

<FrameworkCase frameworks={["html"]}>
HTML element names follow a deliberate pattern:

| Pattern | Example |
|---------|---------|
| `{mediatype}-player` | `video-player` |
| `{style}-{mediatype}-skin` | `frosted-video-skin` |
| `{impl}-{mediatype}` | `hls-video` |
| `media-{action}-{object}` | `media-play-button` |

**Object-last** (`video-player` not `player-video`): Groups related elements together in IDE autocomplete.

**Media type explicit**: Video and audio have different affordances. Separate elements (`video-player` vs `audio-player`) let skins optimize for each.

**`media-*` for primitives**: UI components use the `media-` prefix (like [Media Chrome](https://www.media-chrome.org/)) because they're portable—they work with any player and bind automatically via context.
</FrameworkCase>

<FrameworkCase frameworks={["react"]}>
React uses idiomatic patterns rather than encoding everything in names:

| Concept | Pattern |
|---------|---------|
| Features | `createPlayer({ features: features.video() })` — configuration |
| Skin | `<FrostedSkin>` — component import |
| Media | `<HlsVideo>` — component import |
| Primitives | `<PlayButton>` — component import |

Configuration via props and factory arguments is more natural in React than encoding features in component names. The conceptual model is identical—only the expression differs.
</FrameworkCase>

### Why Do HTML and React Differ?

Both frameworks share the same concepts (Player = state root, Media = playback, Skins = UI), but express them naturally for each platform.

In HTML, the element name *is* the API. `<video-player>` is self-documenting and requires no build step to understand. Custom elements are the platform's composition primitive.

In React, composition happens through imports and props. `createPlayer({ features: features.video() })` followed by `<Provider>` is idiomatic React.

The principle: **start from the same concepts, diverge where it creates a more natural experience**.

### Why Are Skins Standalone Elements?

Skins aren't CSS themes applied to a fixed structure—they're complete component trees. Each skin defines its own layout, controls, and interactions.

This means:
- A streaming skin can have completely different controls than a website skin
- Skins can be optimized for their use case without compromise
- Swapping skins is explicit, not accidental (no CSS specificity battles)

### Why Is Media Independent?

Media elements (`<hls-video>`, `<Video>`) are decoupled from players and skins because:
- The same UI should work regardless of what's playing underneath
- Media choice is often determined by content, not design
- You can swap from MP4 to HLS without touching UI code

Media exposes the same API as native `<video>`, so UI components don't need to know what implementation is underneath.

## See Also

- <DocsLink slug="concepts/features">Features</DocsLink> — State and behavior bundles
- <DocsLink slug="concepts/skins">Skins</DocsLink> — Packaged player designs
- <DocsLink slug="concepts/ui-components">UI Components</DocsLink> — Unstyled primitives
- <DocsLink slug="concepts/media">Media</DocsLink> — Video and audio playback components
