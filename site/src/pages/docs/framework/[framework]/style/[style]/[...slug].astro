---
import type { SupportedFramework, SupportedStyle } from '@/types/docs';
import type { CollectionEntry } from 'astro:content';

import { getCollection, render } from 'astro:content';

import DocsLayout from '@/layouts/Docs.astro';
import { ALL_FRAMEWORK_STYLE_COMBINATIONS } from '@/types/docs';
import { filterSidebar, getAllGuideSlugs, getAdjacentGuides, getSectionsForGuide } from '@/utils/docs/sidebar';
import defaultMarkdownComponents from '@/components/typography/defaultMarkdownComponents';
import { TableOfContents } from '@/components/docs/TableOfContents';
import H3 from '@/components/typography/H3.astro';
import { Selectors } from '@/components/docs/Selectors';
import DocsNavigation from '@/components/docs/DocsNavigation.astro';
import EditPageButton from '@/components/docs/EditPageButton.astro';
import JsonLd from '@/components/JsonLd.astro';
import { createTechArticleSchema } from '@/utils/jsonLd/schemas';
import { getDocTitle } from '@/utils/docs/title';
import CopyMarkdownButton from '@/components/CopyMarkdownButton';

export async function getStaticPaths() {
  const docsCollection = await getCollection('docs');

  /**
   * Build a map of allowed slugs for each framework/style combination.
   * Only docs that appear in the filtered sidebar will be allowed to generate pages.
   */
  type AllowedSlugsMap = Map<string, Set<string>>;
  const allowedSlugsMap: AllowedSlugsMap = new Map();

  for (const { framework, style, key } of ALL_FRAMEWORK_STYLE_COMBINATIONS) {
    const sidebarForFrameworkAndStyle = filterSidebar(framework, style);
    const slugsForFrameworkAndStyle = getAllGuideSlugs(sidebarForFrameworkAndStyle);
    allowedSlugsMap.set(key, new Set(slugsForFrameworkAndStyle));
  }

  // Generate a path for each doc that's visible in at least one framework/style combination
  const staticPaths = ALL_FRAMEWORK_STYLE_COMBINATIONS.flatMap(({ framework, style, key }) => {
    const allowedSlugs = allowedSlugsMap.get(key)!;

    // Filter docs to only those visible in this combination's sidebar
    return docsCollection
      .filter((doc) => allowedSlugs.has(doc.id))
      .map((doc) => ({
        params: {
          framework,
          style,
          slug: doc.id,
        },
        props: { doc },
      }));
  });

  return staticPaths;
}

type Props<F extends SupportedFramework = SupportedFramework> = {
  doc: CollectionEntry<'docs'>;
  framework: F;
  style: SupportedStyle<F>;
};

const { framework, style, slug } = Astro.params;
const { doc } = Astro.props;
const { Content, headings, remarkPluginFrontmatter } = await render(doc);

// Use conditional headings from our remark plugin if available, otherwise fallback to default headings
const conditionalHeadings = remarkPluginFrontmatter?.conditionalHeadings;
const filteredHeadings = conditionalHeadings
  ? conditionalHeadings.filter((h: any) => {
      const matchesFramework = !h.frameworks || h.frameworks.includes(framework);
      const matchesStyle = !h.styles || h.styles.includes(style);
      return matchesFramework && matchesStyle;
    })
  : headings;

// Get adjacent guides for navigation
const { prev, next } = getAdjacentGuides(slug, framework, style);

// Fetch all docs to get their framework-specific titles
const allDocs = await getCollection('docs');
const docTitles = new Map(allDocs.map((d) => [d.id, getDocTitle(d, framework)]));

// Get the section hierarchy for this guide
const sections = getSectionsForGuide(slug, filterSidebar(framework, style));

// Build JSON-LD schema for TechArticle
const pageUrl = new URL(Astro.url.pathname, Astro.site).toString();
const jsonLdSchema = createTechArticleSchema({
  title: getDocTitle(doc, framework),
  description: doc.data.description,
  url: pageUrl,
  updatedDate: doc.data.updatedDate,
  readingTime: remarkPluginFrontmatter.readingTimeMinutes,
  articleSection: sections.length > 0 ? sections.join(' > ') : undefined,
});
---

<DocsLayout doc={doc} framework={framework} style={style} slug={slug}>
  <JsonLd slot="head" schema={jsonLdSchema} />
  <main
    class:list={[
      'flex-1',
      'grid grid-cols-1 xl:grid-cols-(--xl-grid-cols)',
      '[grid-template-areas:var(--grid-template-areas)] xl:[grid-template-areas:var(--xl-grid-template-areas)]',
      'grid-rows-(--grid-rows) xl:grid-rows-1',
      '[--scroll-mt:var(--mobile-toc-h)] xl:[--scroll-mt:0px]',
    ]}
    style="
      --xl-grid-cols: minmax(0, 1fr) calc(var(--spacing) * 59);
      --grid-template-areas: 'selectors' 'toc' 'article';
      --grid-rows: min-content min-content minmax(0, 1fr);
      --xl-grid-template-areas: 'article toc';
      --mobile-toc-h: calc(var(--spacing) * 15);
    "
  >
    <div class="lg:hidden" style="grid-area: selectors;">
      <Selectors client:idle currentFramework={framework} currentStyle={style} currentSlug={slug} />
    </div>
    <div
      class="sticky overflow-y-auto z-30"
      style="grid-area: toc; top: var(--nav-h); max-height: calc(100vh - var(--nav-h));"
    >
      <TableOfContents client:idle headings={filteredHeadings} />
    </div>
    <div class="@container px-6 lg:px-12 flex flex-col" style="grid-area: article;">
      <article
        class="mb-18 flex-1"
        data-pagefind-body
        data-llms-content
        data-llms-description={doc.data.description}
        data-framework={framework}
        data-style={style}
        data-site="docs"
        data-category={sections[0]}
        data-pagefind-filter="framework[data-framework], style[data-style], section[data-site]"
      >
        <header
          class:list={[
            'border-b border-light-40 dark:border-dark-80 max-w-3xl mx-auto py-8 mb-8',
            'flex flex-col md:flex-row gap-4 items-start md:items-end justify-between',
          ]}
        >
          <div>
            <H3 as="h1" class="mt-0 mb-2">{getDocTitle(doc, framework)}</H3>
            <p class="@lg:font-medium">{doc.data.description}</p>
          </div>
          <CopyMarkdownButton client:idle />
        </header>
        <Content components={{ ...defaultMarkdownComponents }} />
      </article>
      <footer class="mb-18 grid gap-5">
        <DocsNavigation prev={prev} next={next} framework={framework} style={style} docTitles={docTitles} />
        <EditPageButton filePath={`site/src/content/docs/${doc.id}.mdx`} />
      </footer>
    </div>
  </main>
</DocsLayout>
